C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 1   


C51 COMPILER V6.12, COMPILATION OF MODULE JKZK
OBJECT MODULE PLACED IN .\Jkzk.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE .\Jkzk.c OPTIMIZE(4,SPEED) 

stmt level    source

   1          /*==============================*/
   2          /*	Jkzk.C			*/
   3          /*	2000.6.20		*/
   4          
   5          /*==============*/
   6          /*  包含头文件  */
   7          /*==============*/
   8          #include <AT89x52.h>
   9          #include <stdarg.h>
  10          #include <intrins.h>
  11          #include "jkzk.h"
  12          
  13          /*==============*/
  14          /*  系统宏定义  */
  15          /*==============*/
  16          #define FREQ    11.0592
  17          #define DELAY_SCALE 100 /*1000/(12/FREQ)*/
  18          #define TIMEBASE    50     /*  定时中断时间,单位ms */
  19          #define T0_INIT     19457   /*0xffff-(TIMEBASE*1000)/(12/FREQ)  */
  20          #define WAITTIME 10
  21          #define COMP_ZERO   200
  22          
  23          /*==================*/
  24          /*  系统变量定义    */
  25          /*==================*/
  26          
  27          unsigned char load,solar_state;
  28          unsigned char Delay_change,Delay_disconnect;
  29          unsigned char sec,time,min,hour;
  30          unsigned char porta,portb;
  31          idata unsigned char buf[6];               /*  接收缓冲区，这是一个先进先出对列  */
  32          unsigned char point;
  33          unsigned long chargeah,dischargeah;
  34          unsigned int btv_H,btv_L;
  35          unsigned int btv;
  36          unsigned char please;
  37          unsigned int adresult;
  38          bit OutDevice;
  39          bit newday,newhour;                           /*  每天 00:00 改变此标志,存当天数据     */
  40          bit IsSolar;
  41          bit received;
  42          bit TEST;
  43          bit TXEN;
  44          bit DISPLAY;
  45          bit ALARMSOUND;
  46          
  47          
  48          /*==================*/
  49          /*  输入输出口定义  */
  50          /*==================*/
  51          sbit Do=0x94;
  52          sbit di=0x95;
  53          sbit clk=0x96;
  54          sbit cs=0x97;
  55          
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 2   

  56          
  57          sbit RS=0xa0;
  58          sbit rw=0xa1;
  59          sbit e=0xa2;
  60          sbit paen=0xa3;
  61          sbit pben=0xa4;
  62          sbit slk=0xa5;		//display clock
  63          sbit dta=0xa6;		// display data
  64          sbit display_pb=0xa7;	//display button
  65          
  66          sbit cs0=0xb2;
  67          sbit wdg=0xb4;
  68          sbit dout=0xb5;
  69          sbit out_en=0xb6;	//P3.6
  70          sbit sk=0xb7;
  71          
  72          
  73          /*======================*/
  74          /*      函数预说明      */
  75          /*======================*/
  76          lcd_init(void);
  77          /*monitor*/ aprintf(char *format,...) reentrant;
  78          delay(unsigned int times);
  79          /*monitor*/ set_eprom(unsigned char command);
  80          /*monitor*/ unsigned int eprom(unsigned char address);
  81          unsigned char wait_key();
  82          /*monitor*/ write_eprom(unsigned char address,unsigned int Data);
  83          sendstr(unsigned char *Data);
  84          unsigned char key();
  85          sendpacket(unsigned char,unsigned int);
  86          void talk(void);
  87          void outchar(char);
  88          
  89          arg(){
  90   1      //    if(eprom(DAY)>=400)while(1){
  91   1      //        lcd_init();
  92   1      //        aprintf("ERROR 601");
  93   1      //    }
  94   1      //	wdg=~wdg;
  95   1          write_eprom(1,eprom(TAPER));
  96   1          write_eprom(2,(eprom(TAPER)*4+eprom(BOOST))/5);
  97   1          write_eprom(3,(eprom(TAPER)*3+eprom(BOOST)*2)/5);
  98   1          write_eprom(4,(eprom(TAPER)*2+eprom(BOOST)*3)/5);
  99   1          write_eprom(5,(eprom(TAPER)+eprom(BOOST)*4)/5);
 100   1          write_eprom(6,eprom(BOOST));
 101   1      }
 102          
 103          /*==============*/
 104          /*  系统初始化  */
 105          /*==============*/
 106          init()
 107          {
 108   1          unsigned char i;
 109   1          out_en=0;
 110   1       //   portb=0;
 111   1       //   portb|=LOAD;
 112   1       //   P0=portb;
 113   1       //   porta=0;
 114   1       //   paen=0;
 115   1       //   pben=0;
 116   1       //   port=P0=LAMP;
 117   1       //   port_out_en=1;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 3   

 118   1       //   port_out_en=0;
 119   1          porta=portb=P0=LAMP;
 120   1          paen=pben=1;
 121   1          paen=pben=0;
 122   1          load=0;                   
 123   1      	ALARMSOUND=1;
 124   1          for(i=0;i<12;i++)outchar(3);
 125   1          write_eprom(BT_V_MIN,1024);
 126   1          /*  LCD显*/
 127   1          OutDevice=LCD;
 128   1          lcd_init();
 129   1          /*  系统状态判别    */
 130   1      #if MODEL==70    
 131   1          aprintf("\a   JRT-48-100");
 132   1      #endif
 133   1      #if MODEL==71
                  aprintf("\a   JRT-24-100");
              #endif
 136   1      	aprintf("\nSystem Init...");
 137   1          delay(8000);
 138   1          TXEN=1;
 139   1          point=0;
 140   1          if(eprom(SYSTEM_FLAG)!=MODEL){
 141   2              aprintf("\aEPROM ERROR!\nLoad Default...");
 142   2              wait_key();
 143   2              write_eprom(BOOST,BOOST_DEFAULT_VALUE);
 144   2              write_eprom(TAPER,TAPER_DEFAULT_VALUE);
 145   2              write_eprom(FLOAT_MAX_S,FLOAT_MAX_DEFAULT_VALUE);
 146   2              write_eprom(FLOAT_MIN_S,FLOAT_MIN_DEFAULT_VALUE);
 147   2              write_eprom(DELAY_CHANGE,DELAY_CHANGE_DEFAULT_VALUE);
 148   2              write_eprom(BOOST_BELOW,BOOST_BELOW_DEFAULT_VALUE);
 149   2              write_eprom(COMP_TEMP,COMP_TEMP_DEFAULT_VALUE);
 150   2              write_eprom(BT_MIN,BT_MIN_DEFAULT_VALUE);
 151   2              write_eprom(BT_MAX,BT_MAX_DEFAULT_VALUE);
 152   2              write_eprom(BT_RELOAD,BT_RELOAD_DEFAULT_VALUE);
 153   2              write_eprom(DELAY_DISCONNECT,DELAY_DISCONNECT_DEFAULT_VALUE);
 154   2              for(i=PASSWORD;i<PASSWORD+8;i++)write_eprom(i,'8');
 155   2              for(i=CLIP;i<CLIP+16;i++)write_eprom(i,128);
 156   2              write_eprom(SYSTEM_FLAG,MODEL);
 157   2          }
 158   1          arg();                                
 159   1          /*  定时器0初始化    */
 160   1      //    IE=0x82;
 161   1      	IE=0x12;
 162   1      	IP=0x10;
 163   1          SCON=0x70;
 164   1          TMOD=0x21;
 165   1          TH1=0xfd;
 166   1          PCON=0;
 167   1          TR0=TR1=1;
 168   1          EA=1;
 169   1      }
 170          
 171          
 172          
 173          /*monitor*/ int ad(unsigned char ch)
 174          {
 175   1          union{
 176   1              unsigned char i[2];
 177   1              unsigned long l;
 178   1          }a;
 179   1          unsigned int result,sum;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 4   

 180   1          porta=((porta&0xf0)|ch);
 181   1          P0=porta;
 182   1          paen=1;
 183   1          paen=0;
 184   1          sum=0;
 185   1          for(a.i[0]=0;a.i[0]<255;a.i[0]++);
 186   1          for(a.i[0]=0;a.i[0]<16;a.i[0]++){
 187   2          	result=0;
 188   2          	sk=0;
 189   2          	dout=1;
 190   2          	cs0=0;
 191   2          	while(!dout);
 192   2          	sk=1;
 193   2          	sk=0;
 194   2          	sk=1;
 195   2          	result|=dout;
 196   2          	sk=0;
 197   2          	for(a.i[1]=0;a.i[1]<11;a.i[1]++){
 198   3              	sk=1;
 199   3              	result=(result<<1)|dout;
 200   3              	sk=0;
 201   3              }
 202   2          	cs0=sk=dout=1;
 203   2          	sum+=result;
 204   2          	wdg=~wdg;
 205   2          }
 206   1          result=sum/16;
 207   1      //    a.l=128+eprom(CLIP+ch);
 208   1      //    a.l=result*a.l;
 209   1      //    result=a.l/1024;
 210   1          return result;
 211   1      }
 212          
 213                  /*
 214          monitor ad_get(unsigned char ch)
 215          {
 216                  if(ch==LOAD_V)return ad_get(BT_V)-ad(ch);
 217                  if(ch==TEMP_BT)return (ad(ch)*4-2732-COMP_ZERO);
 218                  if(ch==BT_V)return ad(ch)-(eprom(COMP_TEMP)*(MODEL==71?12:24)*ad_get(TEMP_BT));
 219                  if(ch==LOAD_I)return ad(ch)/2;
 220                  if(ch==BT_I)return ad(ch);
 221                  if(ch==SR_I0)portb=1;ch=BT_I;
 222                  if(ch==SR_I1)portb=2;ch=BT_I;
 223                  if(ch==SR_I2)portb=4;ch=BT_I;
 224                  if(ch==SR_I3)portb=8;ch=BT_I;
 225                  if(ch==SR_I4)portb=0x10;ch=BT_I;
 226                  if(ch==SR_I5)portb=0x20;ch=BT_I;
 227              if(load!=0)portb|=LOAD;else portb&=~LOAD;
 228              P0=portb;
 229              pben=1;
 230              pben=0;
 231              return ad(ch);
 232          }       */
 233          /*monitor*/ ad_get(unsigned char ch)
 234          {
 235   1      	unsigned int tem;
 236   1      //    EA=0;
 237   1          switch(ch){
 238   2              case LOAD_V:
 239   2      //        	tem=ad(ch)/4;
 240   2      //        	if(btv>tem)return btv-tem;
 241   2      //        	return 0;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 5   

 242   2      			return (ad(ch)*4)/5;
 243   2              case SR_V0:
 244   2              case SR_V1:
 245   2              case SR_V2:
 246   2              case SR_V3:
 247   2              case SR_V4:
 248   2              case SR_V5:
 249   2                portb=portb|0x3f;
 250   2                //if(load!=0)portb&=~LOAD;else portb|=LOAD;
 251   2                P0=portb;
 252   2                pben=1;
 253   2                pben=0;
 254   2                tem=ad(ch);
 255   2      //          return btv+1000-((tem)*2)/5-tem/100;
 256   2      			return 	(tem*4)/5;
 257   2              case TEMP_BT:
 258   2              	tem=(ad(ch)-2732-COMP_ZERO)/10;
 259   2              	if(tem>100)return 0;
 260   2              	return tem;
 261   2      //        case BT_V:return ad(ch)/4;
 262   2      			return (ad(ch)*4)/5;
 263   2              case LOAD_I:return ad(ch)/4;                                             
 264   2              case BT_I:return ad(ch)/2;
 265   2              case SR_I0:portb=(portb|0x3f)&0xfe;ch=BT_I;break;
 266   2              case SR_I1:portb=(portb|0x3f)&0xfd;ch=BT_I;break;
 267   2              case SR_I2:portb=(portb|0x3f)&0xfb;ch=BT_I;break;
 268   2              case SR_I3:portb=(portb|0x3f)&0xf7;ch=BT_I;break;
 269   2              case SR_I4:portb=(portb|0x3f)&0xef;ch=BT_I;break;
 270   2              case SR_I5:portb=(portb|0x3f)&0xdf;ch=BT_I;break;
 271   2              default:return 0;
 272   2          }
 273   1          //if(load!=0)portb&=~LOAD;else portb|=LOAD;
 274   1          P0=portb;
 275   1          pben=1;
 276   1          pben=0;
 277   1      //    EA=1;
 278   1          if(ch==BT_I)return ad(ch)/2;
 279   1      	else return ad(ch)/4;
 280   1      }
 281          
 282          rad_get(unsigned char CH)
 283          {
 284   1      	please=CH;
 285   1      	for(CH=0;CH<255;CH++){
 286   2      		if(please==0xff)return adresult;
 287   2        		delay(20);
 288   2         	}
 289   1      }
 290          
 291          //interrupt [0x0b] void T0_int (void)
 292          void T0_int (void) interrupt 1
 293          {
 294   1      	code unsigned char LEDTABLE[]={0x3,0x9f,0x25,0x0d,0x99,0x49,0x41,0x1f,0x1,0x09,0xff};
 295   1          static unsigned char ms;
 296   1          static unsigned char next_state;
 297   1          unsigned int value;
 298   1          unsigned char tt[12];
 299   1      
 300   1          /*定时器初值设置*/
 301   1          TH0=T0_INIT/256;
 302   1          TL0=T0_INIT%256;
 303   1      	if(please!=0xff){
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 6   

 304   2      		adresult=ad_get(please);
 305   2      		please=0xff;
 306   2      	}
 307   1      	if(received)talk();
 308   1          /*50mS加一*/
 309   1          if((ms++)==(1000/TIMEBASE-1)){
 310   2      
 311   2              /*看门狗复位*/
 312   2              wdg=~wdg;
 313   2              /*1秒*/
 314   2              ms=0;
 315   2              if(DISPLAY){
 316   3                      	value=ad_get(LOAD_I);
 317   3      //                   outchar(value%10);
 318   3                         tt[0]=LEDTABLE[value%10];
 319   3                         value/=10;
 320   3      //                   outchar(
 321   3      				tt[1]=LEDTABLE[value%10]-1;
 322   3                         value/=10;
 323   3      //                   outchar(value%10);
 324   3      				tt[2]=LEDTABLE[value%10];
 325   3                         value/=10;
 326   3      //                   outchar(value%10);
 327   3      				tt[3]=LEDTABLE[value%10];
 328   3                         value=btv;
 329   3      //                   outchar(value%10);
 330   3      				tt[4]=LEDTABLE[value%10];
 331   3                         value/=10;
 332   3      //                   outchar(value%10+0x80);
 333   3      				tt[5]=LEDTABLE[value%10]-1;
 334   3                         value/=10;
 335   3      //                   outchar(value%10);
 336   3      				tt[6]=LEDTABLE[value%10];
 337   3                         value/=10;
 338   3      //                   outchar(value%10);
 339   3      				tt[7]=LEDTABLE[value%10];
 340   3                         value=ad_get(BT_I);
 341   3      //                   outchar(value%10);
 342   3      				tt[8]=LEDTABLE[value%10];
 343   3                         value/=10;
 344   3      //                   outchar(value%10+0x80);
 345   3      				tt[9]=LEDTABLE[value%10]-1;
 346   3                         value/=10;
 347   3      //                   outchar(value%10);
 348   3      				tt[10]=LEDTABLE[value%10];
 349   3                         value/=10;
 350   3      //                   outchar(value%10);
 351   3      				tt[11]=LEDTABLE[value%10];
 352   3        				outchar(tt[0]);
 353   3        				outchar(tt[1]);
 354   3        				outchar(tt[2]);
 355   3        				outchar(tt[3]);
 356   3        				outchar(tt[4]);
 357   3        				outchar(tt[5]);
 358   3        				outchar(tt[6]);
 359   3        				outchar(tt[7]);
 360   3        				outchar(tt[8]);
 361   3        				outchar(tt[9]);
 362   3        				outchar(tt[10]);
 363   3        				outchar(tt[11]);
 364   3                       }
 365   2      
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 7   

 366   2              /*充电流程控制*/
 367   2              btv=ad_get(BT_V);
 368   2              value=btv-(eprom(COMP_TEMP)*(MODEL==71?12:24)*ad_get(TEMP_BT))/100;
 369   2              if(solar_state<7){
 370   3                  if(value<eprom(solar_state-1)){
 371   4                      if(next_state==solar_state-1){
 372   5                          if(Delay_change==0)solar_state-=1;
 373   5                      }
 374   4                      else{
 375   5                          next_state=solar_state-1;
 376   5                          Delay_change=TEST?2:eprom(DELAY_CHANGE);
 377   5                      }
 378   4                  }
 379   3                  else {
 380   4                      if(value>=eprom(solar_state)){
 381   5                          if(next_state==solar_state+1){
 382   6                              if(Delay_change==0)solar_state+=1;
 383   6                          }
 384   5                          else{
 385   6                              next_state=solar_state+1;
 386   6                              Delay_change=TEST?2:eprom(DELAY_CHANGE);
 387   6                          }
 388   5                      }
 389   4                      else next_state=0;
 390   4                  }
 391   3              }
 392   2              else{
 393   3                  if(value<(solar_state==13?eprom(BOOST_BELOW):eprom(FLOAT_MIN_S))){
 394   4                      if(next_state==solar_state+1){
 395   5                          if(Delay_change==0)solar_state=solar_state==13?1:solar_state+1;
 396   5                      }
 397   4                      else{
 398   5                          next_state=solar_state+1;
 399   5                          Delay_change=TEST?2:eprom(DELAY_CHANGE);
 400   5                      }
 401   4                  }
 402   3                  else {
 403   4                      if(value>eprom(FLOAT_MAX_S) && solar_state!=7){
 404   5                          if(next_state==solar_state-1){
 405   6                              if(Delay_change==0)solar_state-=1;
 406   6                          }
 407   5                          else{
 408   6                              next_state=solar_state-1;
 409   6                              Delay_change=TEST?2:eprom(DELAY_CHANGE);
 410   6                          }
 411   5                      }
 412   4                      else next_state=0;
 413   4                  }
 414   3              }
 415   2      //        if(value>eprom(DATA))write_eprom(DATA,value);
 416   2      //        if(value<eprom(DATA+1))write_eprom(DATA+1,value);
 417   2        		if(value>btv_H)btv_H=value;
 418   2      		if(value<btv_L)btv_L=value;
 419   2              chargeah+=ad_get(BT_I);
 420   2              dischargeah+=ad_get(LOAD_I);
 421   2      //        write_eprom(DATA+2,chargeah/36000);
 422   2      //        write_eprom(DATA+3,dischargeah/36000);
 423   2      
 424   2              if(!load){
 425   3                  if(value>eprom(BT_MAX)){
 426   4                      if(Delay_disconnect==0){
 427   5                          porta|=(ALARM_HI|UJ);
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 8   

 428   5                          load=1;
 429   5      					sendpacket(0xfe,load);
 430   5                      }
 431   4                  }
 432   3                  else{
 433   4                      if(value<eprom(BT_MIN)){
 434   5                          if(Delay_disconnect==0){
 435   6                              porta|=(ALARM_LO|UJ);
 436   6                              load=2;
 437   6      						sendpacket(0xfe,load);
 438   6                          }
 439   5                      }
 440   4                      else{
 441   5                          Delay_disconnect=TEST?2:eprom(DELAY_DISCONNECT);
 442   5                      }
 443   4                  }
 444   3              }
 445   2              else{
 446   3                  if(load==1){
 447   4                      if(value<eprom(BT_MAX)-40){
 448   5                          porta&=~(ALARM_HI|UJ);
 449   5                          load=0;
 450   5      					ALARMSOUND=1;
 451   5      					sendpacket(0xfe,load);
 452   5                      }
 453   4                  }
 454   3                  else{
 455   4                      if(value>eprom(BT_RELOAD)){
 456   5                          porta&=~(ALARM_LO|UJ);
 457   5                          load=0;
 458   5      					ALARMSOUND=1;
 459   5      					sendpacket(0xfe,load);
 460   5                      }
 461   4                  }
 462   3              }
 463   2              Delay_change--;
 464   2              Delay_disconnect--;
 465   2      
 466   2              if((sec++)==59){
 467   3                  sec=0;
 468   3                  time++;
 469   3      			sendpacket(0xfe,load);
 470   3                  if((min++)==59){
 471   4                      min=0;
 472   4      				newhour=1;
 473   4                      if((hour++)==23){
 474   5      					hour=0;   
 475   5      					newday=1;
 476   5      				}
 477   4                  }
 478   3              }
 479   2          }
 480   1          value=P0;
 481   1      
 482   1          P0=porta;
 483   1          paen=1;
 484   1          paen=0;
 485   1          switch(solar_state){
 486   2              case 1:
 487   2              case 13:portb=0;break;
 488   2              case 2:
 489   2              case 12:portb=0x20;break;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 9   

 490   2              case 3:
 491   2              case 11:portb=0x30;break;
 492   2              case 4:
 493   2              case 10:portb=0x38;break;
 494   2              case 5:
 495   2              case 9:portb=0x3c;break;
 496   2              case 6:
 497   2              case 8:portb=0x3e;break;
 498   2              case 7:portb=0x3f;break;
 499   2              default:solar_state=1;
 500   2          }
 501   1          if(load!=0){
 502   2      		if(ALARMSOUND)portb|=FMQ;else portb&=~FMQ;
 503   2      	}
 504   1          if(!IsSolar){
 505   2              P0=portb;
 506   2              pben=1;
 507   2              pben=0;
 508   2          }
 509   1          P0=value;
 510   1      }
 511          
 512          void talk(void)
 513          {
 514   1      	unsigned char value;
 515   1          	if(buf[1]==1){			//read variable
 516   2          		switch(buf[2]){
 517   3           			case 0:         //btv
 518   3             				sendpacket(0,btv);
 519   3             		        break;
 520   3             	        case 1:
 521   3             	        	sendpacket(1,ad_get(LOAD_V));
 522   3             	            break;
 523   3             	        case 2:
 524   3             	        	sendpacket(2,ad_get(SR_V0));
 525   3             	            break;
 526   3             	        case 3:
 527   3             	        	sendpacket(3,ad_get(SR_V1));
 528   3             	            break;
 529   3             	        case 4:
 530   3             	        	sendpacket(4,ad_get(SR_V2));
 531   3             	            break;
 532   3             	        case 5:
 533   3             	        	sendpacket(5,ad_get(SR_V3));
 534   3             	            break;
 535   3             	        case 6:
 536   3             	        	sendpacket(6,ad_get(SR_V4));
 537   3             	            break;
 538   3             	        case 7:
 539   3             	        	sendpacket(7,ad_get(SR_V5));
 540   3             	            break;
 541   3             	        case 8:
 542   3             	        	sendpacket(8,ad_get(TEMP_BT)+20);
 543   3             	            break;
 544   3             	        case 9:
 545   3             	        	sendpacket(9,(int)solar_state);
 546   3             	            break;
 547   3             	        case 10:
 548   3             	        	sendpacket(10,(int)load);
 549   3             	            break;
 550   3             	        case 14:    
 551   3             	        	sendpacket(14,ad_get(LOAD_I));
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 10  

 552   3             	            break;
 553   3             	        case 15:
 554   3             	        	sendpacket(15,ad_get(BT_I));
 555   3             	            break;
 556   3             	        case 0x10:
 557   3             	        	sendpacket(0x10,ad_get(SR_I0));
 558   3             	            break;
 559   3             	        case 0x11:
 560   3             	        	sendpacket(0x11,ad_get(SR_I1));
 561   3             	            break;
 562   3             	        case 0x12:
 563   3             	        	sendpacket(0x12,ad_get(SR_I2));
 564   3             	            break;
 565   3             	        case 0x13:
 566   3             	        	sendpacket(0x13,ad_get(SR_I3));
 567   3             	            break;
 568   3             	        case 0x14:
 569   3             	        	sendpacket(0x14,ad_get(SR_I4));
 570   3             	            break;
 571   3             	        case 0x15:
 572   3             	        	sendpacket(0x15,ad_get(SR_I5));
 573   3             	            break;
 574   3             	        case 0x20:
 575   3             	           	sendpacket(0x20,eprom(BOOST));	//BOOST
 576   3             	            break;
 577   3             	        case 0x21:
 578   3             	        	sendpacket(0x21,eprom(TAPER));	//taper
 579   3             	            break;
 580   3             	        case 0x22:
 581   3             	        	sendpacket(0x22,eprom(FLOAT_MAX_S));
 582   3             	            break;
 583   3             	        case 0x23:
 584   3             	        	sendpacket(0x23,eprom(FLOAT_MIN_S));
 585   3             	            break;
 586   3             	        case 0x24:
 587   3             	        	sendpacket(0x24,eprom(BOOST_BELOW));
 588   3             	            break;
 589   3             	        case 0x25:
 590   3             	        	sendpacket(0x25,eprom(COMP_TEMP));
 591   3             	            break;
 592   3             	        case 0x26:
 593   3             	        	sendpacket(0x26,eprom(DELAY_CHANGE));
 594   3             	            break;
 595   3             	        case 0x27:
 596   3             	        	sendpacket(0x27,eprom(BT_MIN));
 597   3             	            break;
 598   3             	        case 0x28:
 599   3             	        	sendpacket(0x28,eprom(BT_RELOAD));
 600   3             	            break;
 601   3             	        case 0x29:
 602   3             	        	sendpacket(0x29,eprom(BT_MAX));
 603   3             	            break;
 604   3             	        case 0x2a:
 605   3             	        	sendpacket(0x2a,eprom(DELAY_DISCONNECT));
 606   3             	            break;
 607   3             	        case 0x2b:
 608   3             	        	sendpacket(0x2b,eprom(BT_V_MIN));
 609   3             	            break;
 610   3             	        case 0x2c:
 611   3             	        	sendpacket(0x2c,eprom(BT_V_MAX));
 612   3             	            break;
 613   3             	        case 0x2d:
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 11  

 614   3             	        	sendpacket(0x2d,eprom(CHARGE_AH));
 615   3             	            break;
 616   3             	        case 0x2e:
 617   3             	        	sendpacket(0x2e,eprom(DISCHARGE_AH));
 618   3             	            break;
 619   3             	        case DATA_INDEX:
 620   3             	        	for(value=DATA;value<DATA+32*4;value++){
 621   4             	        	    sendpacket(value,eprom(value));
 622   4             	                wdg=~wdg;
 623   4             	            }
 624   3             	            break;
 625   3             	        default:sendpacket(0xff,0xff); 
 626   3             		}
 627   2             	}
 628   1             	else{                   //write writeable variable
 629   2             		switch(buf[2]){
 630   3             	        case 0x20:
 631   3             	        	write_eprom(BOOST,buf[3]*256+buf[4]);
 632   3             	        	sendpacket(0x20,eprom(BOOST));	//BOOST
 633   3             	            arg();
 634   3             	            break;
 635   3             	        case 0x21:
 636   3             	        	write_eprom(TAPER,buf[3]*256+buf[4]);
 637   3             	        	sendpacket(0x21,eprom(TAPER));	//taper
 638   3             	            arg();
 639   3             	            break;
 640   3             	        case 0x22:
 641   3             	        	write_eprom(FLOAT_MAX_S,buf[3]*256+buf[4]);
 642   3             	        	sendpacket(0x22,eprom(FLOAT_MAX_S));
 643   3             	            break;
 644   3             	        case 0x23:
 645   3             	        	write_eprom(FLOAT_MIN_S,buf[3]*256+buf[4]);
 646   3             	        	sendpacket(0x23,eprom(FLOAT_MIN_S));
 647   3             	            break;
 648   3             	        case 0x24:
 649   3             	        	write_eprom(BOOST_BELOW,buf[3]*256+buf[4]);
 650   3             	        	sendpacket(0x24,eprom(BOOST_BELOW));
 651   3             	            break;
 652   3             	        case 0x25:
 653   3             	        	write_eprom(COMP_TEMP,buf[3]*256+buf[4]);
 654   3             	        	sendpacket(0x25,eprom(COMP_TEMP));
 655   3             	            break;
 656   3             	        case 0x26:
 657   3             	        	write_eprom(DELAY_CHANGE,buf[3]*256+buf[4]);
 658   3             	        	sendpacket(0x26,eprom(DELAY_CHANGE));
 659   3             	            break;
 660   3             	        case 0x27:
 661   3             	        	write_eprom(BT_MIN,buf[3]*256+buf[4]);
 662   3             	        	sendpacket(0x27,eprom(BT_MIN));
 663   3             	            break;
 664   3             	        case 0x28:
 665   3             	        	write_eprom(BT_RELOAD,buf[3]*256+buf[4]);
 666   3             	        	sendpacket(0x28,eprom(BT_RELOAD));
 667   3             	            break;
 668   3             	        case 0x29:
 669   3             	        	write_eprom(BT_MAX,buf[3]*256+buf[4]);
 670   3             	        	sendpacket(0x29,eprom(BT_MAX));
 671   3             	            break;
 672   3             	        case 0x2a:
 673   3             	        	write_eprom(DELAY_DISCONNECT,buf[3]*256+buf[4]);
 674   3             	        	sendpacket(0x2a,eprom(DELAY_DISCONNECT));
 675   3             	            break;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 12  

 676   3             	     	default:
 677   3             	        	write_eprom(buf[2],buf[3]*256+buf[4]);
 678   3             	            sendpacket(buf[2],eprom(buf[2]));
 679   3             	            break;
 680   3             		}
 681   2             	}
 682   1      		received=0;
 683   1          }
 684          
 685          
 686          /*DELAY()
 687          {
 688              clk=1;
 689              clk=0;
 690          } */
 691            
 692          #define DELAY() clk=1;clk=0;
 693          /*----------------------*/
 694          /*  EPROM设置及擦除程序 */
 695          /*  command=00H,EWDS  */
 696          /*  command=01H,EWEN  */
 697          /*----------------------*/
 698          /*monitor*/ set_eprom(unsigned char command)
 699          {
 700   1          unsigned char k;
 701   1          EA=0;
 702   1          cs=clk=di=0;
 703   1          Do=1;
 704   1          cs=1;
 705   1          while(!Do);
 706   1          di=1;
 707   1          DELAY();
 708   1          if(command==0){
 709   2                  di=0;
 710   2                  DELAY();
 711   2                  DELAY();
 712   2              }
 713   1              else{
 714   2                  di=0;
 715   2                  DELAY();
 716   2                  DELAY();
 717   2                  command=0xc0;
 718   2              }
 719   1          for(k=0;k<8;k++){
 720   2              di=command>>7;
 721   2              DELAY();
 722   2              command<<=1;
 723   2          }
 724   1          cs=0;
 725   1          EA=1;
 726   1      }
 727          
 728          /*--------------------------*/
 729          /*  EPROM写入程序           */
 730          /*  address<256,写单个数据  */
 731          /*--------------------------*/
 732          /*monitor*/ write_eprom(unsigned char address,unsigned int Data)
 733          {
 734   1          unsigned char k;
 735   1          set_eprom(EWEN);
 736   1          EA=0;
 737   1          cs=clk=di=0;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 13  

 738   1          Do=1;
 739   1          cs=1;
 740   1          while(!Do);
 741   1          di=1;
 742   1          DELAY();
 743   1          di=0;
 744   1          DELAY();
 745   1                  di=1;
 746   1          DELAY();
 747   1          for(k=0;k<8;k++){
 748   2              di=address>>7;
 749   2              DELAY();
 750   2              address<<=1;
 751   2          }
 752   1          for(k=0;k<16;k++){
 753   2              di=Data>>15;
 754   2              DELAY();
 755   2              Data<<=1;
 756   2          }
 757   1          cs=0;
 758   1          EA=1;
 759   1          set_eprom(EWDS);
 760   1      }
 761          
 762          /*------------------*/
 763          /*  EPROM读出程序   */
 764          /*------------------*/
 765          /*monitor*/ unsigned int eprom(unsigned char address)
 766          {
 767   1          unsigned char k,i;
 768   1          unsigned int result;
 769   1          EA=0;
 770   1          for(i=0;i<10;i++){
 771   2              cs=clk=di=0;
 772   2              Do=1;
 773   2              cs=1;
 774   2              while(!Do);
 775   2              cs=0;
 776   2              cs=1;
 777   2              di=1;
 778   2              DELAY();
 779   2              DELAY();
 780   2              di=0;
 781   2              DELAY();
 782   2              for(k=0;k<8;k++){
 783   3                  di=address>>7;
 784   3                  DELAY();
 785   3                  address<<=1;
 786   3              }
 787   2              if(Do==0)goto GOOD;
 788   2          }
 789   1          return 0;
 790   1      GOOD:
 791   1          for(k=0;k<16;k++){
 792   2              result<<=1;
 793   2              DELAY();
 794   2              result=result|Do;
 795   2          }
 796   1          cs=0;
 797   1          EA=1;
 798   1          return result;
 799   1      }
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 14  

 800          
 801          /*----------------------*/
 802          /*  液晶显示驱动程序    */
 803          /*  型号:   MDLS-16265B */
 804          /*----------------------*/
 805          /*----------------------*/
 806          /*  液晶显示器判忙程序  */
 807          /*----------------------*/
 808          
 809          /*monitor*/ unsigned char busy()
 810          {
 811   1          unsigned char ac;
 812   1          EA=0;
 813   1          P0=0xff;
 814   1          RS=0;
 815   1          rw=1;
 816   1          e=1;
 817   1          ac=P0;
 818   1          e=0;
 819   1          EA=1;
 820   1          return ac>>7;
 821   1      }
 822          
 823          /*monitor*/ lcd_opr(unsigned char ch)
 824          {
 825   1          while(busy());
 826   1          EA=0;
 827   1          RS=rw=0;
 828   1          P0=ch;
 829   1          e=1;
 830   1          e=0;
 831   1          EA=1;
 832   1      }
 833          
 834          /*--------------------------*/
 835          /*  液晶显示器初始化程序    */
 836          /*--------------------------*/
 837          lcd_init(void)
 838          {
 839   1          /*  工作方式设置,8位数据接口,两行显示,5X7点阵   */
 840   1          lcd_opr(0x38);
 841   1          /*  输入方式选择,AC自动加1,画面不动 */
 842   1          lcd_opr(6);
 843   1          /*  显示开关控制,开显示,关光标,禁止闪烁 */
 844   1          lcd_opr(12);
 845   1          lcd_opr(1);
 846   1      }
 847          
 848          
 849          /*------------------------------*/
 850          /*  单字符显示,供printf()调用   */
 851          /*------------------------------*/
 852          /*monitor*/ aputchar(unsigned char c)  reentrant
 853          {
 854   1      //    if(OutDevice==LCD){
 855   1              while(busy());
 856   1      //        EA=0;
 857   1              RS=rw=0;
 858   1              switch(c){
 859   2                  case '\n':P0=0xc0;break;
 860   2                  case '\b':P0=2;break;
 861   2                  case '\a':P0=1;break;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 15  

 862   2                  default:RS=1;P0=c;
 863   2              }
 864   1              e=1;
 865   1              e=0;
 866   1        //      EA=1;
 867   1      //    }
 868   1      //    else{
 869   1      //       while(usy){
 870   1      //            OutDevice=LCD;
 871   1      //            aprintf("\aPRINTER NOT\n READY...");
 872   1      //            if(key()==CANCEL)return 1;
 873   1      //            OutDevice=PRINTER;
 874   1      //        }
 875   1      //        EA=0;
 876   1      //       P0=c;
 877   1      //       stb=0;
 878   1      //       stb=1;
 879   1      //       EA=1;
 880   1      //       if(c=='\n')aputchar('\r');
 881   1      //    }
 882   1          return 0;
 883   1      }
 884          
 885          /*------------------*/
 886          /*  格式化输出命令  */
 887          /*------------------*/
 888          /*monitor*/ aprintf (char *format,...) reentrant
 889          {
 890   1          unsigned char format_flag,*ptr;                               /*格式标志*/
 891   1          unsigned int div_val, u_val, base;
 892   1          va_list ap;
 893   1          va_start(ap,format);
 894   1      //    EA=0;
 895   1          for (;;){
 896   2              while ((format_flag = *format++) != '%'){      /* Until '%' or '\0' */
 897   3                  if (!format_flag){
 898   4      //                EA=1;
 899   4                      return (1);
 900   4                  }
 901   3                  if(aputchar (format_flag))return 1;
 902   3              }
 903   2              switch (format_flag = *format++){
 904   3                  case 'c':
 905   3                      format_flag = va_arg(ap,char);
 906   3                  default:
 907   3                      if(aputchar (format_flag))return 1;
 908   3                  continue;
 909   3                  case 's':
 910   3                      ptr = va_arg(ap,char *);
 911   3                  while (format_flag = *ptr++){
 912   4                      if(aputchar (format_flag))return 1;
 913   4                  }
 914   3                  continue;
 915   3                  case 'e':
 916   3                      base=10;
 917   3                      div_val=100;
 918   3                      u_val=va_arg(ap,unsigned char);
 919   3                      while(div_val>1&& div_val >u_val){
 920   4                          div_val/=10;
 921   4                      }
 922   3                      do{
 923   4                          aputchar(u_val/div_val+48);
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 16  

 924   4                          u_val%=div_val;
 925   4                          div_val/=base;
 926   4                      }while(div_val);
 927   3                      continue;
 928   3                  case 'o':
 929   3                  case 'd':
 930   3                      base = 10;
 931   3                      div_val = 10000;
 932   3                  u_val = va_arg(ap,int);
 933   3                      while (div_val > 1 && div_val > u_val){
 934   4                          div_val /= 10;
 935   4                      }
 936   3                      if(format_flag=='o' && div_val==1)aputchar('0');
 937   3                  do{
 938   4                      if(format_flag=='o' && div_val==1)aputchar('.');
 939   4                      aputchar (u_val / div_val+48);
 940   4                      u_val %= div_val;
 941   4                      div_val /= base;
 942   4                  }
 943   3                  while (div_val);
 944   3              }
 945   2          }
 946   1      }
 947          
 948          delay(unsigned int time)
 949          {
 950   1          unsigned char j;
 951   1          for(;time>0;time--)for(j=0;j<DELAY_SCALE;j++)wdg=~wdg;
 952   1      }
 953          
 954          unsigned char key()
 955          {
 956   1      //#pragma memory=code
 957   1      //    code unsigned char key_tab[16]={112,115,114,113,
 958   1      //                        179,178,177,211,
 959   1      //                        210,209,227,176,
 960   1      //                        208,226,225,224};
 961   1      //    code unsigned char key_tab[16]={227,211,179,115,//115,114,113,112,
 962   1      //    								226,210,178,114,//179,178,177,176,
 963   1      //       					            225,209,177,113,//211,210,209,208,
 964   1      //       		            			224,208,176,112};//227,226,225,224};
 965   1      //    code unsigned char key_tab[16]={112,176,208,224,
 966   1      //                        113,177,209,225,
 967   1      //                        114,178,210,226,
 968   1      //                        115,179,211,227};
 969   1          code unsigned char key_tab[16]={224,208,176,112,
 970   1                              225,209,177,113,
 971   1                              226,210,178,114,
 972   1                              227,211,179,115};
 973   1      
 974   1      //#pragma memory=default
 975   1          unsigned char j,k;
 976   1          wdg=~wdg;
 977   1          for(j=0;j<4;j++){
 978   2              P1=~(1<<j);
 979   2              k=P1|0xf;
 980   2              if(k!=0xff){
 981   3                  delay(20);
 982   3                  if(k==P1|0xf)k=(k&0xf0)+j;
 983   3                  break;
 984   3              }
 985   2          }
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 17  

 986   1          P1=0xff;
 987   1          for(j=0;j<16;j++){
 988   2              if(key_tab[j]==k){
 989   3                  k=j;
 990   3                  time=0;
 991   3      			if(portb>=FMQ)ALARMSOUND=0;
 992   3                  return k;
 993   3              }
 994   2          }
 995   1          if(display_pb==0){
 996   2          	time=0;
 997   2      		if(portb>=FMQ)ALARMSOUND=0;
 998   2          	return 1;
 999   2          }
1000   1          return NO;
1001   1      }
1002          
1003          unsigned char wait_key()
1004          {
1005   1          unsigned char k;
1006   1          while(key()!=NO&&time<WAITTIME);
1007   1          while((k=key())==NO && time<WAITTIME);
1008   1      	return k;
1009   1      }	
1010          	
1011          unsigned int ascanf(char *format,unsigned char lenth)
1012          {
1013   1          unsigned char k,i;
1014   1          i=0;
1015   1          for(;;){
1016   2              k=wait_key();
1017   2                  if(k== OK)return 1;
1018   2                  if(k== CANCEL && i>0){
1019   3                      i--;
1020   3                      format[i]=0;
1021   3                  }
1022   2                  if(k<10){
1023   3                      if(i<(lenth)){
1024   4                          format[i]=k+48;
1025   4                          i++;
1026   4                          for(k=i;k<lenth;k++)format[k]=0;
1027   4                      }
1028   3                  }
1029   2              aprintf("\n%s            ",format);
1030   2          }
1031   1      }
1032          
1033          unsigned int setup(char *message,int a,int max,int min)
1034          {
1035   1          unsigned char k;
1036   1      loop:
1037   1              lcd_opr(1);
1038   1              aprintf(message,a);
1039   1          if((k=wait_key())==NO)return 0xffff;
1040   1                  if(k== OK)return a;
1041   1                  if(k== INC){
1042   2                      if(a<max)a++;
1043   2                      aprintf(message,a);
1044   2                      while(key()==INC){
1045   3                          delay(500);
1046   3                          while(key()==INC){
1047   4                              if(a<max)a++;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 18  

1048   4                              aprintf(message,a);
1049   4                              delay(200);
1050   4                        }
1051   3                      }
1052   2                  }
1053   1                  if(k== DEC){
1054   2                      if(a>min)a--;
1055   2                      aprintf(message,a);
1056   2                      while(key()==DEC){
1057   3                          delay(500);
1058   3                          while(key()==DEC){
1059   4                              if(a>min)a--;
1060   4                              aprintf(message,a);
1061   4                              delay(200);
1062   4                         }
1063   3                      }
1064   2              }
1065   1          goto loop;
1066   1      }
1067          
1068          char password()
1069          {
1070   1          unsigned char pass[4],i;
1071   1          for(i=0;i<4;i++)pass[i]=0;
1072   1          aprintf("\aEnter Password:");
1073   1          ascanf(pass,3);
1074   1          for(i=0;i<3;i++){
1075   2              if(pass[i]!=eprom(PASSWORD+i)){
1076   3                  aprintf("\bPassword Error!");
1077   3                  wait_key();
1078   3                  aprintf("\a");
1079   3                  return 0;
1080   3              }
1081   2          }
1082   1          return 1;
1083   1      }
1084          
1085          control_set()
1086          {
1087   1          unsigned char k;
1088   1      //    #pragma memory=code
1089   1          code unsigned char *prompt[]={"\bMAXIMUM BOOST\nVOLTAGE %oV ",
1090   1                          "\bBOOST TAPER AT\nVOLTAGE %oV ",
1091   1                          "\bFLOAT MAXIMUM\nVOLTAGE %oV ",
1092   1                          "\bFLOAT MINIMUM\nVOLTAGE %oV ",
1093   1                          "\bRETURN TO BOOST\nMODE BELOW %oV ",
1094   1                          "\bTEMPERATURE COMP\nAT -%dmV/C/CELL ",
1095   1                          "\bSTATE CHANGE\nDELAY %d S  "
1096   1                      };
1097   1          code unsigned int MAX[]={BOOST_MAX,TAPER_MAX,FLOAT_MAX,FLOAT_MAX,BOOST_BELOW_MAX,COMP_TEMP_MAX,DELAY_C
             -HANGE_MAX};
1098   1          code unsigned int MIN[]={BOOST_MIN,TAPER_MIN,FLOAT_MIN,FLOAT_MIN,BOOST_BELOW_MIN,COMP_TEMP_MIN,DELAY_C
             -HANGE_MIN};
1099   1      //    #pragma memory=default
1100   1          unsigned int temp[7];
1101   1          if(!password())return 0;
1102   1          for(k=0;k<7;k++)
1103   1              if((temp[k]=setup(prompt[k],eprom(BOOST+k),MAX[k],MIN[k]))==0xffff)return 0;
1104   1          aprintf("\aSAVE CHANGE?\nINC=YES OTHER=NO");
1105   1          if(wait_key()==INC){
1106   2              for(k=0;k<7;k++)write_eprom(BOOST+k,temp[k]);
1107   2              arg();
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 19  

1108   2          }
1109   1          lcd_opr(1);
1110   1      }
1111          
1112          load_setup()
1113          {
1114   1          unsigned char k;
1115   1      //    #pragma memory=code
1116   1          code unsigned char *prompt[]={
1117   1              "\bLOW BATTERY AL-\nARM ON AT %oV ",
1118   1              "\bRECONNECT LOAD\nABOVE %oV ",
1119   1              "\bHIGH BATTERY AL-\nARM ON AT %oV ",
1120   1              "\bDELAY BEFORE\nDISCONNECT %d S  "
1121   1          };
1122   1          code unsigned int MAX[]={BT_MIN_MAX,BT_RELOAD_MAX,BT_MAX_MAX,DELAY_DIS_MAX};
1123   1          code unsigned int MIN[]={BT_MIN_MIN,BT_RELOAD_MIN,BT_MAX_MIN,DELAY_DIS_MIN};
1124   1      //    #pragma memory=default
1125   1          unsigned int temp[4];
1126   1          if(!password())return 0;
1127   1          for(k=0;k<4;k++)
1128   1              if((temp[k]=setup(prompt[k],eprom(BT_MIN+k),MAX[k],MIN[k]))==0xffff)return 0;
1129   1          aprintf("\aSAVE CHANGE?\nINC=YES OTHER=NO");
1130   1          if(wait_key()==INC){
1131   2              set_eprom(EWEN);
1132   2              for(k=0;k<4;k++)
1133   2                  write_eprom(BT_MIN+k,temp[k]);
1134   2              set_eprom(EWDS);
1135   2              arg();
1136   2          }
1137   1          lcd_opr(1);
1138   1      }
1139          
1140          
1141          remote_set()
1142          {
1143   1      //    #pragma memory=code
1144   1      //    code unsigned char *prompt[]={"OFF","ON"};
1145   1      //    #pragma memory=default
1146   1          unsigned char /*Phone[1],*/Local/*,Up_hour,Up_min*/;
1147   1          bit Upload=1;
1148   1      //    unsigned char k;
1149   1          if(!password())return 0;
1150   1      /*    Upload=eprom(AUTO_UPLOAD);*/
1151   1          Local=eprom(LOCAL);
1152   1      /*    for(k=0;k<12;k++)Phone[k]=eprom(PHONE+k);
1153   1          Phone[12]=0;*/
1154   1      /*    while(1){
1155   1              k=Upload;
1156   1              aprintf("\aAuto Upload:\n[%s] ",prompt[k]);
1157   1              k=wait_key();
1158   1              if(k==NO)return 0;
1159   1              if(k==DEC || k==INC)Upload=~Upload;
1160   1              if(k==OK)break;
1161   1          }*/
1162   1      /*    if(Upload){*/
1163   1              if((Local=setup("\bSit Number:\n%d  ",eprom(LOCAL),255,0))==0xffff)return 0;
1164   1      /*        if((Up_hour=setup("\bUpload Hour:\n%d ",eprom(UP_HOUR),23,0))==0xffff)return 0;
1165   1              if((Up_min =setup("\bUpload Minute:\n%d ",eprom(UP_MIN),59,0))==0xffff)return 0;
1166   1              aprintf("\aRemote Phone:\n%s",Phone);
1167   1              if(!ascanf(Phone,12))return 0;
1168   1          }*/
1169   1          aprintf("\aSAVE CHANGE?\nINC=YES OTHER=NO");
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 20  

1170   1          if(wait_key()==INC){
1171   2              set_eprom(EWEN);
1172   2      /*        write_eprom(AUTO_UPLOAD,Upload);*/
1173   2              write_eprom(LOCAL,Local);
1174   2      /*        for(k=0;k<12;k++)write_eprom(PHONE+k,Phone[k]);
1175   2              write_eprom(UP_HOUR,Up_hour);
1176   2              write_eprom(UP_MIN,Up_min);*/
1177   2              set_eprom(EWDS);
1178   2              arg();
1179   2          }
1180   1          lcd_opr(1);
1181   1      }
1182          
1183          
1184          char state(unsigned char a)
1185          {
1186   1          return ((portb>>a)&1)?'0':'1';
1187   1      }
1188          
1189          solar()
1190          {
1191   1      //    #pragma memory=code
1192   1          code char *prompt[]={"OFF","ON"};
1193   1      //    #pragma memory=default
1194   1          unsigned char bank=0;
1195   1          bit change=1;
1196   1          lcd_opr(1);
1197   1          IsSolar=1;
1198   1          while(1){
1199   2          	if(change){
1200   3          	 	aprintf("\bBANK%e %oVoc   ",bank+1,rad_get(SR_V0+bank));
1201   3            		change=0;
1202   3             	}
1203   2              aprintf("\n[%s]     %oA  ",prompt[state(bank)-'0'],rad_get(SR_I0+bank));
1204   2              delay(200);
1205   2              switch(key()){
1206   3                  case INC:bank=(bank+1)%6;change=1;break;
1207   3                  case DEC:if(bank==0)bank=5;else bank--;change=1;break;
1208   3                  case SOLAR:change=1;
1209   3                  case NO:break;
1210   3                  default:IsSolar=0;lcd_opr(1);return 0;
1211   3              }
1212   2              if(time>WAITTIME){
1213   3                      lcd_opr(1);
1214   3                      IsSolar=0;
1215   3                      return 0;
1216   3              }
1217   2          }
1218   1      }
1219          
1220          view()
1221          {
1222   1          unsigned char k,address;
1223   1          unsigned char i;
1224   1          i=k=0;
1225   1          for(;;){
1226   2      		wdg=~wdg;
1227   2              address=i*4+DATA;
1228   2              aprintf("\aD%e H:%o L:%oV",i,eprom(address),eprom(address+1));
1229   2              aprintf("\nC:%d D:%d",eprom(address+2),eprom(address+3));
1230   2              switch(wait_key()){
1231   3                  case INC:i=(i+1)%32;break;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 21  

1232   3                  case DEC:if(i==0)i=31;else i--;break;
1233   3      			case F1:{
1234   4      				aprintf("\aClear Histroy!\nAre you sure?");
1235   4      				if(wait_key()==OK){
1236   5      					for(i=0;i<128;i++)write_eprom(DATA+i,0);
1237   5      				}
1238   4      				i=0;
1239   4      			}
1240   3      			break;
1241   3                  default:lcd_opr(1);return 0;
1242   3              }
1243   2           }
1244   1      }
1245          
1246          testself()
1247          {
1248   1      //    #pragma memory=code
1249   1          code char *prompt[]={
1250   1              "Test Mode",
1251   1              "Meter Adjust"
1252   1          };
1253   1      //    #pragma memory=default
1254   1          
1255   1          unsigned char k=0,l;
1256   1          unsigned char i=0;
1257   1          while(k!=OK){
1258   2              aprintf("\a%s ",prompt[i]);
1259   2              k=wait_key();
1260   2              if(k==0xff || k==CANCEL)return 0;
1261   2              if(k==INC || k==DEC)if(i==0)i=1;else i=0;
1262   2          }
1263   1          if(i==0){
1264   2              TEST=1;
1265   2              while(time<60 && key()!=CANCEL){
1266   3                  aprintf("\bTEST A:%e",solar_state);
1267   3                  aprintf(" %c",state(0));
1268   3                  aprintf("%c",state(1));
1269   3                  aprintf("%c" ,state(2));
1270   3                  aprintf("%c",state(3));
1271   3                  aprintf("%c",state(4));
1272   3                  aprintf("%c  ",state(5));
1273   3                  aprintf("\nB: %oV T:%d ",btv,rad_get(TEMP_BT)+20);
1274   3                  delay(500);
1275   3              }
1276   2              Delay_change=eprom(DELAY_CHANGE);
1277   2              Delay_disconnect=eprom(DELAY_DISCONNECT);
1278   2              TEST=0;
1279   2          }
1280   1          else{
1281   2              for(i=0;i<16;i++){
1282   3                  k=NO;
1283   3                  l=eprom(CLIP+i);
1284   3                  while(k!=OK){
1285   4                      aprintf("\aIN %e\n%e  ",i,l);
1286   4                      k=wait_key();
1287   4                      if(k==NO || k==CANCEL)return 0;
1288   4                      if(k==INC)l++;
1289   4                      if(k==DEC)l--;
1290   4                  }
1291   3                  write_eprom(CLIP+i,l);
1292   3                  lcd_opr(1);
1293   3              }
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 22  

1294   2          }
1295   1      /*    else{
1296   1              set_eprom(EWEN);
1297   1              for(i=0;i<256;i++){
1298   1                  tmp=eprom(i);
1299   1                  write_eprom(i,0);
1300   1                  if(eprom(i)!=0)goto ERR;
1301   1                  write_eprom(i,0xff);
1302   1                  if(eprom(i)!=0xff)goto ERR;
1303   1                  write_eprom(i,tmp);
1304   1                  if(eprom(i)!=tmp)goto ERR;
1305   1              }
1306   1              aprintf("\bEEPROM TEST OK!");
1307   1              while(wait_key()!=OK);
1308   1              goto next;
1309   1      ERR:
1310   1              aprintf("\bEEPROM TEST \nFAILED!");
1311   1              while(wait_key()!=OK);
1312   1              return 0;
1313   1      next:
1314   1              for(i=0;i<6;i++){
1315   1                  EA=0;
1316   1                  portb=1<<i;
1317   1                  P0=portb;
1318   1                  pben=1;
1319   1                  pben=0;
1320   1                  while(key()!=CANCEL)aprintf("\bTEST B:  BANK%d\n  %oA  ",i,ad_get(BT_I));
1321   1              }
1322   1              EA=1;
1323   1          }*/
1324   1          lcd_opr(1);
1325   1      }
1326          
1327          
1328          save()
1329          {
1330   1          char i;
1331   1          set_eprom(EWEN);
1332   1          for(i=30;i>=0;i--){
1333   2              write_eprom(DATA+(i+1)*4,eprom(DATA+i*4));
1334   2              write_eprom(DATA+(i+1)*4+1,eprom(DATA+i*4+1));
1335   2              write_eprom(DATA+(i+1)*4+2,eprom(DATA+i*4+2));
1336   2              write_eprom(DATA+(i+1)*4+3,eprom(DATA+i*4+3));
1337   2          }
1338   1          write_eprom(DATA,btv_H);
1339   1          write_eprom(DATA+1,btv_L);
1340   1          write_eprom(DATA+2,chargeah/36000);
1341   1          write_eprom(DATA+3,dischargeah/36000);
1342   1          set_eprom(EWDS);
1343   1          chargeah=dischargeah=0;
1344   1      	btv_H=0;
1345   1      	btv_L=10000;
1346   1          sendstr("AT&FE0V0X0S0=1\r");
1347   1      }
1348          
1349          
1350          void outchar(char cc)
1351          {
1352   1      	unsigned char i;
1353   1      	for(i=0;i<8;i++){
1354   2        		cc=cc>>1;
1355   2       		if(CY)dta=0;
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 23  

1356   2        		else dta=1;
1357   2        		slk=1;
1358   2        		slk=0;
1359   2      		slk=0;
1360   2      		slk=0;
1361   2      		slk=0;
1362   2        		slk=1;
1363   2        	}
1364   1      }
1365          
1366          main()
1367          {
1368   1      //    unsigned int tt;
1369   1          init();
1370   1          chargeah=dischargeah=0;
1371   1      	btv_H=0;
1372   1      	btv_L=10000;
1373   1      //    set_eprom(EWEN);
1374   1      //    write_eprom(DATA,0);
1375   1      //    write_eprom(DATA+1,10000);
1376   1      //    set_eprom(EWDS);
1377   1          TEST=0;
1378   1          sendstr("AT&F\r");
1379   1      	delay(100);
1380   1      	sendstr("ATE0V0X0\r");
1381   1      	delay(100);
1382   1      	sendstr("ATS0=2S10=10\r");
1383   1      //	sendstr("AT&FE0V0X0S0=2S10=10\r");
1384   1          goto start;
1385   1          while(1){
1386   2              if(key()!=NO){
1387   3      start:
1388   3                  lcd_init();
1389   3                  porta|=LAMP;
1390   3                  P0=porta;
1391   3                  paen=1;
1392   3                  paen=0;
1393   3                  DISPLAY=1;
1394   3                  while(time<WAITTIME){
1395   4                      aprintf("\bBATTERY VOLTAGE\n          %oV ",btv);
1396   4                      switch(key()){
1397   5                          case BT_V_KEY:{
1398   6                              while(key()==BT_V_KEY);
1399   6                              aprintf("\a");
1400   6                              while(key()==NO&&time<WAITTIME){
1401   7                                  aprintf("\bBATTERY VOLTAGE\n          %oV ",btv);
1402   7                                  delay(500);
1403   7                              }
1404   6                              lcd_opr(1);
1405   6                              break;
1406   6                          }
1407   5                          case BT_I_KEY:{
1408   6                              while(key()==BT_I_KEY);
1409   6                              aprintf("\a");
1410   6                              while(key()==NO&&time<WAITTIME){
1411   7                                  aprintf("\bCHARGE CURRENT\n          %oA ",rad_get(BT_I));
1412   7                                  delay(500);
1413   7                              }
1414   6                              lcd_opr(1);
1415   6                              break;
1416   6                          }
1417   5                          case LOAD_V_KEY:{
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 24  

1418   6                              while(key()==LOAD_V_KEY);
1419   6                              aprintf("\a");
1420   6                              while(key()==NO&&time<WAITTIME){
1421   7                                  aprintf("\bLOAD VOLTAGE\n          %oV ",rad_get(LOAD_V));
1422   7                                  delay(500);
1423   7                              }
1424   6                              lcd_opr(1);
1425   6                              break;
1426   6                          }
1427   5                          case LOAD_I_KEY:{
1428   6                              while(key()==LOAD_I_KEY);
1429   6                              aprintf("\a");
1430   6                              while(key()==NO&&time<WAITTIME){
1431   7                                  aprintf("\bLOAD CURRENT\n          %oA ",rad_get(LOAD_I));
1432   7                                  delay(500);
1433   7                              }
1434   6                              lcd_opr(1);
1435   6                              break;
1436   6                          }
1437   5                          case SOLAR:solar();break;
1438   5                          case CONTROL_SET:control_set();break;
1439   5                          case TESTSELF:testself();break;
1440   5                          case REMOTE_SET:remote_set();break;
1441   5                          case LOAD_SET:load_setup();break;
1442   5                          case VIEW:view();break;
1443   5       //                   case F1:ToPrinter();aprintf("\a");break;
1444   5       //                   case F2:graph();aprintf("\a");
1445   5                      }
1446   4      //	        if(recviced()){
1447   4      //                tt=getb();
1448   4      //                if(/*tt==local||*/tt==0xff){
1449   4      //                	send('K');
1450   4      //                    aprintf("\aRemote Connect!");
1451   4      //	                talk();
1452   4      //	            }
1453   4      //	        }
1454   4                  }
1455   3                  lcd_opr(8);
1456   3                  porta&=~LAMP;
1457   3                  P0=porta;
1458   3                  DISPLAY=0;
1459   3                  paen=1;
1460   3                  paen=0;
1461   3                  outchar(0xff);
1462   3                  outchar(0xff);
1463   3                  outchar(0xff);
1464   3                  outchar(0xff);
1465   3                  outchar(0xff);
1466   3                  outchar(0xff);
1467   3                  outchar(0xff);
1468   3                  outchar(0xff);
1469   3                  outchar(0xff);
1470   3                  outchar(0xff);
1471   3                  outchar(0xff);
1472   3                  outchar(0xff);
1473   3              }
1474   2      /*        if(up_load && hour==eprom(UP_HOUR) && min>=eprom(UP_MIN)){
1475   2                  if(dial()==1){
1476   2                      talk();
1477   2                      up_load=0;
1478   2                  }
1479   2              }*/
C51 COMPILER V6.12  JKZK                                                                   06/29/2002 14:26:59 PAGE 25  

1480   2      //        if(recviced()){
1481   2      //            tt=getb();
1482   2      //            if(/*tt==local||*/tt==0xff){
1483   2      //            	send('K');
1484   2      //            	port|=LAMP;
1485   2      //            	P0=port;
1486   2      //            	port_out_en=1;
1487   2      //            	port_out_en=0;
1488   2      //            	lcd_init();
1489   2      //                aprintf("\bRemote Connect!");
1490   2      //                talk();
1491   2      //                port&=~LAMP;
1492   2      //            	P0=port;
1493   2      //            	port_out_en=1;
1494   2      //            	port_out_en=0;
1495   2      //            	lcd_opr(8);
1496   2      //            }
1497   2      //        }
1498   2      		if(newhour){
1499   3          		write_eprom(DATA,btv_H);
1500   3          		write_eprom(DATA+1,btv_L);
1501   3          		write_eprom(DATA+2,chargeah/36000);
1502   3          		write_eprom(DATA+3,dischargeah/36000);
1503   3      			newhour=0;
1504   3      		}
1505   2              if(newday){
1506   3                  save();
1507   3                  newday=0;
1508   3              }
1509   2      
1510   2          }
1511   1      }
1512          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8129    ----
   CONSTANT SIZE    =    952    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30      78
   IDATA SIZE       =      6    ----
   BIT SIZE         =      9       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
